{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "platform.althq.com/v1",
  "title": "Platform Service Spec v1",
  "description": "Schema for platform.yaml (apiVersion: platform.althq.com/v1)",
  "type": "object",
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "additionalProperties": false,
  "properties": {
    "apiVersion": {
      "type": "string",
      "const": "platform.althq.com/v1"
    },
    "kind": {
      "type": "string",
      "const": "Service"
    },
    "metadata": {
      "type": "object",
      "title": "Metadata",
      "description": "Name and description for this service.",
      "required": [
        "name"
      ],
      "additionalProperties": false,
      "x-order": [
        "name",
        "description"
      ],
      "properties": {
        "name": {
          "type": "string",
          "title": "Service name",
          "minLength": 2,
          "maxLength": 63,
          "pattern": "^[a-z][a-z0-9-]*[a-z0-9]$",
          "description": "DNS-safe service name (lowercase letters, numbers, hyphens). Used for stack names, DNS, and resource tagging."
        },
        "description": {
          "type": "string",
          "title": "Description",
          "description": "Optional human-readable description of what this service does."
        }
      }
    },
    "spec": {
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "compute": {
          "type": "object",
          "title": "Compute (ECS)",
          "description": "Runs your app as an ECS Fargate service with ALB, DNS, and Cloudflare Access. Best for long-running containers (web apps, APIs, workers).",
          "additionalProperties": false,
          "x-order": [
            "port",
            "cpu",
            "memory",
            "instances",
            "healthCheck",
            "publicPaths"
          ],
          "properties": {
            "type": {
              "type": "string",
              "title": "Compute type",
              "enum": [
                "ecs"
              ],
              "default": "ecs",
              "description": "Container orchestration type. Only ECS Fargate is supported."
            },
            "port": {
              "type": "integer",
              "title": "Container port",
              "minimum": 1,
              "maximum": 65535,
              "default": 80,
              "description": "Port your app listens on inside the container. HTTPS (443) is terminated at Cloudflare/ALB; ALB forwards to this port."
            },
            "cpu": {
              "type": "integer",
              "title": "CPU units",
              "minimum": 256,
              "default": 512,
              "description": "ECS Fargate CPU units. 256 = 0.25 vCPU, 512 = 0.5 vCPU, 1024 = 1 vCPU, 2048 = 2 vCPU."
            },
            "memory": {
              "type": "integer",
              "title": "Memory (MiB)",
              "minimum": 512,
              "default": 1024,
              "description": "Container memory in MiB. Must be compatible with the chosen CPU units (e.g. 512 CPU \u2192 1024\u20132048 MB, 1024 CPU \u2192 2048\u20138192 MB)."
            },
            "instances": {
              "type": "object",
              "title": "Instances",
              "description": "Scaling configuration for the ECS service.",
              "additionalProperties": false,
              "x-order": [
                "min"
              ],
              "properties": {
                "min": {
                  "type": "integer",
                  "title": "Minimum instances",
                  "minimum": 0,
                  "default": 1,
                  "description": "Minimum number of running tasks. Set to 0 to allow scale-to-zero (service stops when idle). Set to 1 or more to keep the service always warm."
                }
              }
            },
            "healthCheck": {
              "type": "object",
              "title": "Health check",
              "description": "ALB health check settings. The ALB pings this path every 30 seconds; the service must return HTTP 200.",
              "additionalProperties": false,
              "x-order": [
                "path"
              ],
              "properties": {
                "path": {
                  "type": "string",
                  "title": "Health check path",
                  "default": "/health",
                  "description": "HTTP path the ALB uses to verify the service is healthy (e.g. /health, /ping, /). Must return 200 OK with no auth required. If your app doesn't have a health endpoint, add one \u2014 it's required for ALB routing."
                }
              }
            },
            "publicPaths": {
              "type": "array",
              "title": "Public paths",
              "description": "URL path patterns that Cloudflare Zero Trust will allow without authentication. All other paths on this service require Google OAuth via Zero Trust. Use this for webhook receivers, OAuth callbacks, or any endpoint that external systems call directly. You must implement the corresponding routes in your app — this only configures Cloudflare to let the requests through. Examples: /webhooks/*, /api/public/*, /oauth/callback.",
              "items": {
                "type": "string",
                "title": "Path pattern",
                "description": "URL path pattern to allow publicly without Zero Trust auth (e.g. /webhooks/*, /api/public/*)."
              }
            }
          }
        },
        "secrets": {
          "type": "array",
          "title": "Secrets",
          "description": "List of secret names to inject as environment variables. Values must be set as GitHub repo secrets; only names are stored in platform.yaml.",
          "items": {
            "type": "string",
            "title": "Secret name",
            "description": "Name of a GitHub repo secret (e.g. DATABASE_URL, API_KEY)."
          }
        },
        "storage": {
          "type": "object",
          "title": "Storage (EFS)",
          "description": "Provisions an EFS (NFS) filesystem with mount targets and an access point. Containers or Lambdas can mount it for shared persistent storage (e.g. model weights, uploaded files, shared scratch space).",
          "additionalProperties": false,
          "x-order": [
            "efs"
          ],
          "properties": {
            "efs": {
              "type": "object",
              "title": "EFS configuration",
              "description": "Amazon Elastic File System settings.",
              "additionalProperties": false,
              "x-order": [
                "encrypted",
                "lifecycle",
                "accessPoint"
              ],
              "properties": {
                "encrypted": {
                  "type": "boolean",
                  "title": "Encrypted at rest",
                  "default": true,
                  "description": "Encrypt the EFS filesystem at rest using AWS-managed keys. AWS handles all encryption and decryption transparently \u2014 no changes needed in your application code. Recommended: leave this on."
                },
                "lifecycle": {
                  "type": "string",
                  "title": "Infrequent-access transition",
                  "enum": [
                    "AFTER_7_DAYS",
                    "AFTER_14_DAYS",
                    "AFTER_30_DAYS",
                    "AFTER_90_DAYS"
                  ],
                  "default": "AFTER_30_DAYS",
                  "description": "Move files to cheaper infrequent-access storage after this period of inactivity. Files are still fully accessible \u2014 AWS moves them back automatically when read. Your app will not break or notice. This only affects cost: infrequent-access storage is ~85% cheaper than standard EFS. Choose a shorter period if your files are rarely accessed."
                },
                "accessPoint": {
                  "type": "object",
                  "title": "Access point",
                  "description": "EFS access point defines the root directory and POSIX identity for mounts. Most teams can leave the defaults unchanged.",
                  "additionalProperties": false,
                  "x-order": [
                    "path",
                    "uid",
                    "gid"
                  ],
                  "properties": {
                    "path": {
                      "type": "string",
                      "title": "Mount path",
                      "default": "/data",
                      "description": "Root directory within EFS that this access point exposes. Your container sees this as the root of the mounted volume. Default /data is fine for most use cases."
                    },
                    "uid": {
                      "type": "integer",
                      "title": "POSIX user ID (uid)",
                      "default": 1000,
                      "description": "POSIX user ID that owns files written through this access point. Must match the user your container process runs as. In most Docker images, the default non-root user is UID 1000. Only change if your Dockerfile sets a different USER. Sharing UID 1000 across services is safe \u2014 each service mounts its own separate EFS filesystem."
                    },
                    "gid": {
                      "type": "integer",
                      "title": "POSIX group ID (gid)",
                      "default": 1000,
                      "description": "POSIX group ID for file ownership. Must match the group your container process runs as. Typically 1000 to match the default non-root group in most Docker images. Only change if your Dockerfile sets a different GROUP."
                    }
                  }
                }
              }
            }
          }
        },
        "cache": {
          "type": "object",
          "title": "Cache (Redis)",
          "description": "Creates an ElastiCache Redis cluster in the VPC. Use for sessions, rate limiting, pub/sub, or job queues. The Redis endpoint is injected as an environment variable.",
          "additionalProperties": false,
          "x-order": [
            "nodeType",
            "numNodes"
          ],
          "properties": {
            "engine": {
              "type": "string",
              "title": "Engine",
              "enum": [
                "redis"
              ],
              "default": "redis",
              "description": "Cache engine. Only Redis is supported."
            },
            "nodeType": {
              "type": "string",
              "title": "Node type",
              "enum": [
                "cache.t3.micro",
                "cache.t3.small",
                "cache.t3.medium",
                "cache.r6g.large",
                "cache.r6g.xlarge",
                "cache.r6g.2xlarge"
              ],
              "default": "cache.t3.micro",
              "description": "ElastiCache node instance type. Determines memory and throughput. t3.micro (~$13/mo, 0.5 GB) is fine for dev/light workloads. t3.small (~$26/mo, 1.37 GB) for moderate traffic. r6g.large (~$120/mo, 13 GB) for production with large datasets."
            },
            "numNodes": {
              "type": "integer",
              "title": "Number of nodes",
              "minimum": 1,
              "default": 1,
              "description": "Number of cache nodes. Use 1 for a single-node cluster (no replication). Use 2+ for a primary-replica setup with automatic failover."
            }
          }
        },
        "database": {
          "type": "object",
          "title": "Database (RDS Postgres)",
          "description": "Creates an RDS PostgreSQL instance in the VPC. Not exposed to the internet. Accessible only from services in the same VPC. Connection details are injected as environment variables.",
          "additionalProperties": false,
          "required": [
            "dbName",
            "dbUsername"
          ],
          "x-order": [
            "dbName",
            "dbUsername",
            "instanceClass",
            "allocatedStorage",
            "engine"
          ],
          "properties": {
            "engine": {
              "type": "string",
              "title": "Engine",
              "enum": [
                "postgres"
              ],
              "default": "postgres",
              "description": "Database engine. Only PostgreSQL is supported."
            },
            "instanceClass": {
              "type": "string",
              "title": "Instance size",
              "enum": [
                "db.t3.micro",
                "db.t3.small",
                "db.t3.medium",
                "db.t3.large",
                "db.r6g.large",
                "db.r6g.xlarge",
                "db.r6g.2xlarge"
              ],
              "default": "db.t3.micro",
              "description": "RDS instance size. Determines CPU, memory, and IOPS. db.t3.micro (~$15/mo, 2 vCPU, 1 GB) for dev/light workloads. db.t3.small (~$30/mo, 2 GB) for moderate traffic. db.r6g.large (~$180/mo, 2 vCPU, 16 GB) for production."
            },
            "allocatedStorage": {
              "type": "integer",
              "title": "Storage (GiB)",
              "minimum": 20,
              "default": 20,
              "description": "Initial disk size in GiB. Minimum 20 GiB. Storage can be increased later without downtime but cannot be decreased."
            },
            "dbName": {
              "type": "string",
              "title": "Database name",
              "description": "Name of the initial database to create inside Postgres (e.g. myapp_db, agent_store, core). This is what your app connects to. Avoid hyphens \u2014 use underscores. Example: my_service_db."
            },
            "dbUsername": {
              "type": "string",
              "title": "Master username",
              "description": "Username for the Postgres superuser created by RDS (e.g. myapp_admin, db_owner). The platform creates this user and stores the password as a secret \u2014 your app never sets it directly. Your app uses this username (and the injected password env var) to connect. Example: myservice_admin."
            }
          }
        },
        "dynamodb": {
          "type": "object",
          "title": "DynamoDB",
          "description": "Grants your ECS task full access to the declared DynamoDB tables. Tables are created by your application on startup — the platform provisions IAM so the task role can read, write, and manage exactly these tables (and nothing else). Use this instead of RDS when you don't need SQL joins or strict relational constraints.",
          "additionalProperties": false,
          "required": ["tables"],
          "x-order": ["tables"],
          "properties": {
            "tables": {
              "type": "array",
              "title": "Tables",
              "description": "Declare each table your service will use. The platform scopes IAM access to exactly these table names. Your application is responsible for calling CreateTable on startup (if the table does not already exist). You can add tables later by re-running pulumi up — no existing tables are affected.",
              "minItems": 1,
              "items": {
                "type": "object",
                "title": "Table",
                "additionalProperties": false,
                "required": ["name", "partitionKey"],
                "x-order": ["name", "partitionKey", "partitionKeyType", "sortKey", "sortKeyType", "ttlAttribute", "billingMode"],
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "Table name",
                    "description": "DynamoDB table name. Must be unique in the AWS account and region. Convention: prefix with your service name (e.g. agent-factory-jobs, agent-factory-agents). Hyphens are fine."
                  },
                  "partitionKey": {
                    "type": "string",
                    "title": "Partition key",
                    "description": "Name of the attribute used as the partition key (hash key). This is the primary way DynamoDB distributes and retrieves items. Choose a high-cardinality attribute that you always know when reading (e.g. job_id, user_id, agent_id). Avoid low-cardinality values like status or type as the partition key — they cause hot partitions."
                  },
                  "partitionKeyType": {
                    "type": "string",
                    "title": "Partition key type",
                    "enum": ["S", "N", "B"],
                    "default": "S",
                    "description": "Data type of the partition key. S = String (most common), N = Number, B = Binary."
                  },
                  "sortKey": {
                    "type": "string",
                    "title": "Sort key (optional)",
                    "description": "Name of the optional sort key (range key). Together with the partition key, forms the composite primary key. Use when you query items under the same partition in a range — e.g. all events for a user sorted by timestamp, or all messages in a session sorted by sequence number. Leave blank if you always look up items by a single unique ID."
                  },
                  "sortKeyType": {
                    "type": "string",
                    "title": "Sort key type",
                    "enum": ["S", "N", "B"],
                    "default": "S",
                    "description": "Data type of the sort key. S = String, N = Number (use for numeric timestamps), B = Binary. Only used if sort key is set."
                  },
                  "ttlAttribute": {
                    "type": "string",
                    "title": "TTL attribute (optional)",
                    "description": "Name of the item attribute that holds the TTL expiry timestamp (Unix epoch in seconds). DynamoDB automatically deletes items after this time — no manual cleanup needed. Useful for session data, job history, or any data with a natural expiry. Example: expires_at. Your application must write this attribute when creating items."
                  },
                  "billingMode": {
                    "type": "string",
                    "title": "Billing mode",
                    "enum": ["PAY_PER_REQUEST", "PROVISIONED"],
                    "default": "PAY_PER_REQUEST",
                    "description": "PAY_PER_REQUEST (on-demand): you pay per read/write, no capacity planning needed. Good for variable or unpredictable traffic. PROVISIONED: you specify read/write capacity units upfront — cheaper at high, steady throughput but requires capacity planning. Start with PAY_PER_REQUEST and switch to PROVISIONED only if costs become significant."
                  }
                }
              }
            }
          }
        },
        "serviceDiscovery": {
          "type": "object",
          "title": "Service Discovery (Cloud Map)",
          "description": "Creates an AWS Cloud Map private DNS namespace so services can find each other by hostname inside the VPC \u2014 without needing hardcoded IPs or external DNS. For example, if your namespace is agents.local, your service is reachable at my-service.agents.local from other services in the same VPC. Only add this if you have multiple services that need to call each other directly by name (e.g. an orchestrator calling worker services).",
          "additionalProperties": false,
          "x-order": [
            "namespace"
          ],
          "properties": {
            "namespace": {
              "type": "string",
              "title": "DNS namespace",
              "description": "Private DNS domain for service-to-service discovery within the VPC (e.g. agents.local, internal.althq.com). Once set, your service registers under <service-name>.<namespace>. Other VPC services use that hostname to call it directly \u2014 no load balancer or public URL needed. If you only have one service, or your services already communicate through the public ALB URL, you probably don't need this."
            }
          }
        },
        "lambda": {
          "type": "object",
          "title": "Lambda functions",
          "description": "Provisions AWS Lambda functions using container images from ECR. Each function is a separate Lambda. For Agent Factory: provision your Lambda(s) here first \u2014 the platform creates the function resource and IAM role. Then your CI/CD workflow builds the container image and pushes it to ECR. You can use a placeholder image name now; the function will not be invokable until the image is pushed. This decouples infrastructure provisioning from code deployment.",
          "additionalProperties": false,
          "x-order": [
            "functions"
          ],
          "properties": {
            "functions": {
              "type": "array",
              "title": "Functions",
              "description": "One entry per Lambda function to provision.",
              "items": {
                "type": "object",
                "title": "Lambda function",
                "description": "A single Lambda function definition.",
                "additionalProperties": false,
                "required": [
                  "name",
                  "image"
                ],
                "x-order": [
                  "name",
                  "image",
                  "memory",
                  "timeout"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "Function name",
                    "minLength": 1,
                    "description": "Unique name for this Lambda within the service (e.g. agent-runner, pdf-processor). Used as the Lambda function name in AWS."
                  },
                  "image": {
                    "type": "string",
                    "title": "ECR image name",
                    "minLength": 1,
                    "description": "ECR repository name for this function's container image (without tag or registry prefix). The platform resolves the full URI as <account>.dkr.ecr.<region>.amazonaws.com/<image>:latest. Example: my-service-agent-runner. Your CI/CD workflow must push an image to this exact name. You can use a placeholder name now \u2014 the function won't be invokable until an image is pushed."
                  },
                  "memory": {
                    "type": "integer",
                    "title": "Memory (MiB)",
                    "minimum": 128,
                    "default": 2048,
                    "description": "Lambda memory allocation in MiB. Lambda CPU is proportional to memory. 2048 MiB (~1 vCPU) is a good default for ML/agent workloads. Minimum 128 MiB, maximum 10240 MiB."
                  },
                  "timeout": {
                    "type": "integer",
                    "title": "Timeout (seconds)",
                    "minimum": 1,
                    "default": 120,
                    "description": "Maximum execution time in seconds before Lambda terminates the function. Agent and ML workloads often need longer timeouts. Maximum is 900 seconds (15 minutes)."
                  }
                }
              }
            }
          }
        },
        "eventbridge": {
          "type": "object",
          "title": "EventBridge Scheduler",
          "description": "Creates an EventBridge Scheduler group \u2014 a named container for scheduled rules (cron or rate-based). The group itself does not create schedules; you add individual schedules to it independently via the AWS console or CLI, with no redeploy required. Use this when you need time-based triggers (nightly jobs, polling tasks).",
          "additionalProperties": false,
          "x-order": [
            "scheduleGroup"
          ],
          "properties": {
            "scheduleGroup": {
              "type": "string",
              "title": "Schedule group name",
              "description": "Name for the EventBridge Scheduler group (e.g. my-service-schedules). After provisioning, add individual schedules to this group via the AWS console or CLI \u2014 no redeploy needed per schedule. Defaults to <service-name>-schedules if omitted."
            }
          }
        },
        "s3": {
          "type": "object",
          "title": "Object Storage (S3)",
          "description": "Creates S3 buckets for file and object storage. The engine auto-prefixes bucket names with the AWS account ID for global uniqueness.",
          "additionalProperties": false,
          "required": ["buckets"],
          "x-order": ["buckets"],
          "properties": {
            "buckets": {
              "type": "array",
              "title": "Buckets",
              "description": "One or more S3 buckets to create. The engine prefixes each name with the AWS account ID for global uniqueness.",
              "minItems": 1,
              "items": {
                "type": "object",
                "title": "Bucket",
                "additionalProperties": false,
                "required": ["name"],
                "x-order": ["name", "versioning", "encryption", "lifecycleRules"],
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "Bucket name (logical)",
                    "minLength": 3,
                    "maxLength": 50,
                    "pattern": "^[a-z0-9][a-z0-9-]*[a-z0-9]$",
                    "description": "Logical bucket name. The engine prepends the AWS account ID to create the real bucket name ({account_id}-{name})."
                  },
                  "versioning": {
                    "type": "boolean",
                    "title": "Versioning",
                    "default": false,
                    "description": "Enable S3 versioning to keep previous versions of every object."
                  },
                  "encryption": {
                    "type": "string",
                    "title": "Encryption",
                    "enum": ["AES256", "aws:kms"],
                    "default": "AES256",
                    "description": "Server-side encryption method. AES256 (SSE-S3) is free and transparent."
                  },
                  "lifecycleRules": {
                    "type": "array",
                    "title": "Lifecycle rules",
                    "description": "Optional rules to automatically transition or expire objects.",
                    "items": {
                      "type": "object",
                      "title": "Lifecycle rule",
                      "additionalProperties": false,
                      "required": ["prefix"],
                      "x-order": ["prefix", "transitionToIA", "expirationDays"],
                      "properties": {
                        "prefix": {
                          "type": "string",
                          "title": "Object prefix",
                          "description": "S3 key prefix this rule applies to. Use empty string for all objects."
                        },
                        "transitionToIA": {
                          "type": "integer",
                          "title": "Transition to Infrequent Access (days)",
                          "minimum": 1,
                          "description": "Move objects to S3 Infrequent Access after this many days."
                        },
                        "expirationDays": {
                          "type": "integer",
                          "title": "Expire after (days)",
                          "minimum": 1,
                          "description": "Permanently delete objects after this many days."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "agentcoreRuntime": {
          "type": "object",
          "title": "AI Agent Compute (AgentCore Runtime)",
          "description": "Creates AWS Bedrock AgentCore Runtime definitions for AI agents. Sessions run in isolated microVMs with consumption-based pricing.",
          "additionalProperties": false,
          "required": ["runtimes"],
          "x-order": ["runtimes", "authorizer"],
          "properties": {
            "runtimes": {
              "type": "array",
              "title": "Runtimes",
              "description": "One or more AgentCore Runtime definitions.",
              "minItems": 1,
              "items": {
                "type": "object",
                "title": "Runtime",
                "additionalProperties": false,
                "required": ["name", "image"],
                "x-order": ["name", "image", "description", "networkMode", "environmentVariables"],
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "Runtime name",
                    "minLength": 1,
                    "maxLength": 48,
                    "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                    "description": "Unique name for this runtime. Must start with a letter, followed by letters, numbers, or underscores (AWS naming constraint)."
                  },
                  "image": {
                    "type": "string",
                    "title": "ECR image name",
                    "minLength": 1,
                    "description": "ECR repository name for this runtime's container image (without tag or registry prefix)."
                  },
                  "description": {
                    "type": "string",
                    "title": "Description",
                    "maxLength": 1200,
                    "description": "Optional human-readable description."
                  },
                  "networkMode": {
                    "type": "string",
                    "title": "Network mode",
                    "enum": ["PUBLIC", "VPC"],
                    "default": "PUBLIC",
                    "description": "PUBLIC: internet access. VPC: runs in private subnets for VPC-internal resources."
                  },
                  "environmentVariables": {
                    "type": "object",
                    "title": "Environment variables",
                    "description": "Key-value pairs injected as environment variables. Secrets go in the top-level secrets section.",
                    "additionalProperties": {
                      "type": "string"
                    }
                  }
                }
              }
            },
            "authorizer": {
              "type": "object",
              "title": "Authorizer",
              "description": "Optional JWT authorizer for request validation.",
              "additionalProperties": false,
              "x-order": ["type", "discoveryUrl", "allowedAudiences", "allowedClients"],
              "properties": {
                "type": {
                  "type": "string",
                  "title": "Authorizer type",
                  "enum": ["jwt"],
                  "default": "jwt",
                  "description": "Authorization method. Only JWT is supported."
                },
                "discoveryUrl": {
                  "type": "string",
                  "title": "OIDC discovery URL",
                  "format": "uri",
                  "description": "OpenID Connect discovery endpoint for JWT validation."
                },
                "allowedAudiences": {
                  "type": "array",
                  "title": "Allowed audiences",
                  "description": "Accepted 'aud' values in the JWT.",
                  "items": { "type": "string" }
                },
                "allowedClients": {
                  "type": "array",
                  "title": "Allowed clients",
                  "description": "Optional accepted 'azp' or 'client_id' values.",
                  "items": { "type": "string" }
                }
              }
            }
          }
        }
      }
    }
  }
}