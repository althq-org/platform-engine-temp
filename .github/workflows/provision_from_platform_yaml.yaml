# Reusable workflow: provision a service from platform.yaml (ECR, ECS, ALB listener rule, Cloudflare DNS).
# Called by service repos (e.g. my-ecs-service) on push to main.
name: Provision from platform.yaml

on:
  workflow_call:
    inputs:
      service_repo:
        description: "Repo containing platform.yaml (e.g. althq-org/my-ecs-service)"
        required: true
        type: string
      ref:
        description: "Ref to checkout (branch or SHA)"
        required: false
        default: main
        type: string
      platform_yaml_path:
        description: "Path to platform.yaml relative to repo root"
        required: false
        default: platform.yaml
        type: string
      stack:
        description: "Environment stack (e.g. dev)"
        required: false
        default: dev
        type: string
      aws_region:
        description: "AWS region"
        required: true
        type: string
      aws_acct_id:
        description: "AWS account ID"
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  provision:
    name: Provision and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout platform-engine-temp
        uses: actions/checkout@v4
        with:
          repository: althq-org/platform-engine-temp
          ref: main
          path: engine
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout service repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.service_repo }}
          ref: ${{ inputs.ref }}
          path: service
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install PyYAML
        run: |
          python3 -m pip install PyYAML
          python3 -c "import yaml; print('PyYAML OK')"

      - name: Get service name from platform.yaml
        id: service_name
        run: |
          SERVICE_NAME=$(python3 -c "import yaml; print(yaml.safe_load(open('service/${{ inputs.platform_yaml_path }}'))['metadata']['name'])")
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          role-to-assume: arn:aws:iam::${{ inputs.aws_acct_id }}:role/platform_engine_temp_workflows

      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install Pulumi and dependencies
        working-directory: engine
        run: |
          uv sync
          curl -fsSL https://get.pulumi.com | sh
          echo "$HOME/.pulumi/bin" >> $GITHUB_PATH

      - name: Select or create Pulumi stack
        working-directory: engine
        env:
          PLATFORM_YAML_PATH: ${{ github.workspace }}/service/${{ inputs.platform_yaml_path }}
          PULUMI_BACKEND_URL: s3://${{ inputs.aws_acct_id }}-pulumi-backend-software
        run: |
          STACK_NAME="${{ inputs.stack }}.${{ steps.service_name.outputs.service_name }}.${{ inputs.aws_region }}"
          export PATH="$HOME/.local/bin:$HOME/.pulumi/bin:$PATH"
          
          echo "Attempting to select stack: $STACK_NAME"
          if uv run pulumi stack select "$STACK_NAME" -C devops 2>&1; then
            echo "✓ Selected existing stack"
            echo "Stack info:"
            uv run pulumi stack -C devops 2>&1 || true
          else
            echo "Stack does not exist, creating with KMS secrets provider"
            echo "KMS alias: awskms://alias/pulumi_backend_software?region=${{ inputs.aws_region }}"
            uv run pulumi stack init "$STACK_NAME" \
              --secrets-provider="awskms://alias/pulumi_backend_software?region=${{ inputs.aws_region }}" \
              -C devops
            echo "✓ Stack created"
            echo "Stack info:"
            uv run pulumi stack -C devops 2>&1 || true
          fi

      - name: Set Pulumi config
        working-directory: engine
        env:
          PULUMI_BACKEND_URL: s3://${{ inputs.aws_acct_id }}-pulumi-backend-software
        run: |
          export PATH="$HOME/.local/bin:$HOME/.pulumi/bin:$PATH"
          uv run pulumi config set aws:region ${{ inputs.aws_region }} -C devops

      - name: Export secrets from platform.yaml
        env:
          ALL_SECRETS: ${{ toJSON(secrets) }}
        run: |
          # Read which secrets this service needs from platform.yaml
          REQUIRED_SECRETS=$(python3 -c "
          import yaml
          config = yaml.safe_load(open('service/${{ inputs.platform_yaml_path }}'))
          secrets = config.get('spec', {}).get('secrets', [])
          print(' '.join(secrets))
          ")
          
          if [ -z "$REQUIRED_SECRETS" ]; then
            echo "No secrets declared in platform.yaml"
            exit 0
          fi
          
          # Export each required secret to GITHUB_ENV
          for SECRET_NAME in $REQUIRED_SECRETS; do
            SECRET_VALUE=$(echo "$ALL_SECRETS" | jq -r ".[\"$SECRET_NAME\"] // empty")
            if [ -n "$SECRET_VALUE" ]; then
              # Mask the secret value in logs
              echo "::add-mask::$SECRET_VALUE"
              echo "$SECRET_NAME=$SECRET_VALUE" >> $GITHUB_ENV
              echo "✓ Found secret: $SECRET_NAME"
            else
              echo "⚠ Missing secret: $SECRET_NAME (not set in GitHub secrets)"
            fi
          done

      - name: Pulumi up
        working-directory: engine
        env:
          PLATFORM_YAML_PATH: ${{ github.workspace }}/service/${{ inputs.platform_yaml_path }}
          AWS_REGION: ${{ inputs.aws_region }}
          PULUMI_BACKEND_URL: s3://${{ inputs.aws_acct_id }}-pulumi-backend-software
        run: |
          export PATH="$HOME/.local/bin:$HOME/.pulumi/bin:$PATH"
          uv run pulumi up --yes --non-interactive -C devops

      - name: Get Pulumi outputs
        id: pulumi_outputs
        working-directory: engine
        run: |
          export PATH="$HOME/.local/bin:$HOME/.pulumi/bin:$PATH"
          ECR_URI=$(uv run pulumi stack output --json -C devops 2>/dev/null | jq -r '.ecr_repository_uri // empty')
          CLUSTER=$(uv run pulumi stack output --json -C devops 2>/dev/null | jq -r '.ecs_cluster_name // empty')
          SERVICE=$(uv run pulumi stack output --json -C devops 2>/dev/null | jq -r '.ecs_service_name // empty')
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "cluster=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service=$SERVICE" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ inputs.aws_region }} | docker login --username AWS --password-stdin ${{ inputs.aws_acct_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com

      - name: Build and push Docker image
        run: |
          ECR_URI="${{ steps.pulumi_outputs.outputs.ecr_uri }}"
          docker build -t "$ECR_URI:latest" ./service
          docker push "$ECR_URI:latest"

      - name: Force ECS service deployment
        run: |
          aws ecs update-service \
            --cluster "${{ steps.pulumi_outputs.outputs.cluster }}" \
            --service "${{ steps.pulumi_outputs.outputs.service }}" \
            --force-new-deployment \
            --region ${{ inputs.aws_region }}

      - name: Output service URL
        run: |
          echo "Service URL: https://${{ steps.service_name.outputs.service_name }}.althq-dev.com"
